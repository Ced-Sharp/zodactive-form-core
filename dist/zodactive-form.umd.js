(function(m,t){typeof exports=="object"&&typeof module<"u"?t(exports,require("zod")):typeof define=="function"&&define.amd?define(["exports","zod"],t):(m=typeof globalThis<"u"?globalThis:m||self,t(m.ZodactiveForm={},m.zod))})(this,function(m,t){"use strict";const F=(e,o)=>e.constructor.name===o.name,i=new Map;i.set(t.z.ZodBoolean.name,()=>!1),i.set(t.z.ZodNumber.name,()=>0),i.set(t.z.ZodString.name,()=>""),i.set(t.z.ZodArray.name,()=>[]),i.set(t.z.ZodRecord.name,()=>({})),i.set(t.z.ZodDefault.name,e=>e._def.defaultValue()),i.set(t.z.ZodEffects.name,e=>p(e._def.schema)),i.set(t.z.ZodOptional.name,e=>F(e._def.innerType,t.z.ZodDefault)?e._def.innerType._def.defaultValue():void 0),i.set(t.z.ZodTuple.name,e=>{const o=[];for(const d of e._def.items)o.push(p(d));return o}),i.set(t.z.ZodEffects.name,e=>p(e._def.schema)),i.set(t.z.ZodUnion.name,e=>p(e._def.options[0])),i.set(t.z.ZodObject.name,e=>b(e)),i.set(t.z.ZodRecord.name,e=>b(e)),i.set(t.z.ZodIntersection.name,e=>b(e));function p(e){const o=e.constructor.name;if(!i.has(o)){console.warn("getSchemaDefaultForField: Unhandled type",e.constructor.name);return}return i.get(o)(e)}function b(e){if(F(e,t.z.ZodRecord))return{};if(F(e,t.z.ZodEffects))return b(e._def.schema);if(F(e,t.z.ZodIntersection))return Object.assign(Object.assign({},b(e._def.left)),b(e._def.right));if(F(e,t.z.ZodUnion)){for(const o of e._def.options)if(F(o,t.z.ZodObject))return b(o);return console.warn("getSchemaDefaultObject: No object found in union, returning empty object"),{}}return F(e,t.z.ZodObject)?Object.fromEntries(Object.entries(e.shape).map(([o,d])=>[o,p(d)]).filter(o=>o[1]!==void 0)):(console.warn(`getSchemaDefaultObject: Expected object schema, got ${e.constructor.name}`),{})}function V(e){return b(e)}const O=e=>e.constructor.name===t.z.ZodEffects.name?e._def.schema:e,w=e=>e instanceof t.z.ZodObject||e instanceof t.z.ZodIntersection,h=(e,o)=>Object.fromEntries(Object.entries(e).map(([d,Z])=>{const f=O(o).shape,j=f[d];if(!w(j))return[d,{value:Z,error:""}];const _=h(Z,f[d]);return[d,_]})),z=(e,o,d)=>{const Z=e.createReactive,f=e.setReactive,j=e.getReactive,_=d||V(o),R=h(_,o),g=Z(),y=Z(),l=Z();f(g,!1),f(y,[]),f(l,R);const S=(n,r)=>{for(const u in n){const s=n[u],c=Object.prototype.toString.call(s)==="[object Object]";c&&"value"in s&&"error"in s?r(s):c&&S(s,r)}},T=(n,r)=>{const u={};for(const s in n){const c=n[s],a=Object.prototype.toString.call(c)==="[object Object]";a&&"value"in c&&"error"in c?u[s]=r(c):a&&(u[s]=T(c,r))}return u},D=n=>{const r=[...n],u=n.join(".");let s=j(l),c=O(o).shape;for(;r.length>0;){const a=r.shift();if(!a)throw new Error(`Failed to assign form field "${u}".`);if(!(a in s))if(a in c)if(c[a].constructor.name===t.z.ZodOptional.name)s[a]={value:void 0,error:""};else throw new Error(`Failed to assign form field "${u}".`);else throw new Error(`Failed to assign form field "${u}".`);s=s[a];const E=c[a];(E&&"shape"in E||"_def"in E)&&(c=O(E).shape)}return s},P=n=>Array.isArray(n)?n:n!=null&&n.includes(".")?n.split("."):[n],$=(n,r)=>{const u=D(P(n));u.value=r,f(l,j(l))},x=()=>{f(l,R)},v=()=>{f(y,[]);const n=j(l);S(n,r=>{r.error=""}),f(l,j(l))},A=()=>{const n=j(l);return T(n,r=>r.value)},N=()=>{var n;v();try{return o.parse(A()),f(g,!0),!0}catch(r){if(typeof r=="object"&&((n=r==null?void 0:r.constructor)==null?void 0:n.name)===t.ZodError.name){const u=j(l),s=r.flatten();for(const c in s.fieldErrors){const a=s.fieldErrors[c];u[c].error=a!=null&&a.length?a[0]:""}return f(y,[...s.formErrors]),f(l,j(l)),f(g,!1),!1}throw f(g,!1),r}};return N(),v(),{form:l,formErrors:y,valid:g,assign:$,clear:x,clearErrors:v,validate:N,toJson:A,getFieldByPath:D}};m.getObj=O,m.isFieldAnObject=w,m.objectToFormFields=h,m.useZodactiveForm=z,Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});
